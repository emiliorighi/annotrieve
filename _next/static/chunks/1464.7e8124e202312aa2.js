(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1464],{81464:function(t,e,s){"use strict";s.r(e),s.d(e,{default:function(){return E}});var r=s(51936),a=s(93900),i=s(93458);async function n(t,e,s={}){let{defaultContent:r={}}=s;try{let s=await e(t,{encoding:"utf8"}),r=new TextDecoder("utf8");return JSON.parse(r.decode(s))}catch(t){if("ENOENT"===t.code||404===t.status||t.message.includes("404")||t.message.includes("ENOENT"))return r;throw t}}function o(t,e="."){return i(t,e)}class h{constructor({readFile:t,cacheSize:e=100}){if(this.topList=[],this.chunkCache=new a.Z({cache:new r({maxSize:e}),fill:this.readChunkItems.bind(this)}),this.readFile=t,!this.readFile)throw Error('must provide a "readFile" function')}importExisting(t,e,s,r,a){this.topList=t,this.attrs=e,this.start=e.makeFastGetter("Start"),this.end=e.makeFastGetter("End"),this.lazyClass=a,this.baseURL=s,this.lazyUrlTemplate=r}binarySearch(t,e,s){let r,a=-1,i=t.length;for(;i-a>1;)s(t[r=a+i>>>1])>=e?i=r:a=r;return s===this.end?i:a}readChunkItems(t){return n(o(this.lazyUrlTemplate.replaceAll(/\{Chunk\}/gi,t),this.baseURL),this.readFile,{defaultContent:[]})}async *iterateSublist(t,e,s,r,a,i,n){let o=this.attrs.makeGetter("Chunk"),h=this.attrs.makeGetter("Sublist"),l=[];for(let c=this.binarySearch(t,e,a);c<t.length&&c>=0&&r*i(t[c])<r*s;c+=r){if(t[c][0]===this.lazyClass){let e=o(t[c]),s=this.chunkCache.get(e,e).then(t=>[t,e]);l.push(s)}else yield[t[c],n.concat(c)];let u=h(t[c]);u&&(yield*this.iterateSublist(u,e,s,r,a,i,n.concat(c)))}for(let t of l){let[o,h]=await t;o&&(yield*this.iterateSublist(o,e,s,r,a,i,[...n,h]))}}async *iterate(t,e){let s=t>e?this.start:this.end,r=t>e?this.end:this.start;this.topList.length>0&&(yield*this.iterateSublist(this.topList,t,e,t>e?-1:1,s,r,[0]))}async histogram(t,e,s){let r=Array(s);r.fill(0);let a=(e-t)/s;for await(let i of this.iterate(t,e)){let e=Math.max(0,(this.start(i)-t)/a|0),n=Math.min(s,(this.end(i)-t)/a|0);for(let t=e;t<=n;t+=1)r[t]+=1}return r}}class l{constructor(t){this.classes=t,this.fields=[];for(let e=0;e<t.length;e+=1){this.fields[e]={};for(let s=0;s<t[e].attributes.length;s+=1)this.fields[e][t[e].attributes[s]]=s+1;void 0===t[e].proto&&(t[e].proto={}),void 0===t[e].isArrayAttr&&(t[e].isArrayAttr={})}}attrIndices(t){return this.classes.map(e=>e.attributes.indexOf(t)+1||e.attributes.indexOf(t.toLowerCase())+1||void 0)}get(t,e){if(e in this.fields[t[0]])return t[this.fields[t[0]][e]];let s=e.toLowerCase();if(s in this.fields[t[0]])return t[this.fields[t[0]][s]];let r=this.classes[t[0]].attributes.length+1;return!(r>=t.length)&&e in t[r]?t[r][e]:e in this.classes[t[0]].proto?this.classes[t[0]].proto[e]:void 0}makeSetter(t){return(e,s)=>{this.set(e,t,s)}}makeGetter(t){return e=>this.get(e,t)}makeFastGetter(t){let e=this.attrIndices(t);return function(t){if(void 0!==e[t[0]])return t[e[t[0]]]}}accessors(){return this._accessors||(this._accessors=this._makeAccessors()),this._accessors}_makeAccessors(){let t={},e={get(t){let e=this.get.field_accessors[t.toLowerCase()];if(e)return e.call(this)},set(t,e){let s=this.set.field_accessors[t];if(s)return s.call(this,e)},tags(){return s[this[0]]||[]}};e.get.field_accessors={},e.set.field_accessors={},this.classes.forEach((e,s)=>{(e.attributes||[]).forEach((e,r)=>{t[e]=t[e]||[],t[e][s]=r+1,t[e=e.toLowerCase()]=t[e]||[],t[e][s]=r+1})});let s=this.classes.map(t=>t.attributes);return Object.keys(t).forEach(s=>{let r=t[s];e.get.field_accessors[s]=r?function(){return this[r[this[0]]]}:function(){}}),e}}class c{constructor({urlTemplate:t,chunkSize:e,length:s,cacheSize:i=100,readFile:n},o){if(this.urlTemplate=t,this.chunkSize=e,this.length=s,this.baseUrl=void 0===o?"":o,this.readFile=n,!n)throw Error("must provide readFile callback");this.chunkCache=new a.Z({cache:new r({maxSize:i}),fill:this.getChunk.bind(this)})}index(t,e,s){this.range(t,t,e,void 0,s)}async *range(t,e){t=Math.max(0,t),e=Math.min(e,this.length-1);let s=Math.floor(t/this.chunkSize),r=Math.floor(e/this.chunkSize),a=[];for(let t=s;t<=r;t+=1)a.push(this.chunkCache.get(t,t));for(let s of a){let[r,a]=await s;yield*this.filterChunkData(t,e,r,a)}}async getChunk(t){let e=this.urlTemplate.replaceAll(/\{Chunk\}/gi,t);return this.baseUrl&&(e=o(e,this.baseUrl)),[t,await n(e,this.readFile)]}*filterChunkData(t,e,s,r){let a=s*this.chunkSize,i=Math.max(0,t-a),n=Math.min(e-a,this.chunkSize-1);for(let t=i;t<=n;t+=1)yield[t+a,r[t]]}}function u(){return this._uniqueID}function f(){return this._parent}function d(){return this.get("subfeatures")}class g{constructor({baseUrl:t,urlTemplate:e,readFile:s,cacheSize:i=10}){if(this.baseUrl=t,this.urlTemplates={root:e},this.readFile=s,!this.readFile)throw Error('must provide a "readFile" function argument');this.dataRootCache=new a.Z({cache:new r({maxSize:i}),fill:this.fetchDataRoot.bind(this)})}makeNCList(){return new h({readFile:this.readFile})}loadNCList(t,e,s){t.nclist.importExisting(e.intervals.nclist,t.attrs,s,e.intervals.urlTemplate,e.intervals.lazyClass)}getDataRoot(t){return this.dataRootCache.get(t,t)}fetchDataRoot(t){let e=o(this.urlTemplates.root.replaceAll(/{\s*refseq\s*}/g,t),this.baseUrl);return n(e,this.readFile).then(t=>this.parseTrackInfo(t,e))}parseTrackInfo(t,e){let s={nclist:this.makeNCList(),stats:{featureCount:t.featureCount||0}};t.intervals&&(s.attrs=new l(t.intervals.classes),this.loadNCList(s,t,e));let{histograms:r}=t;if(r?.meta){for(let t=0;t<r.meta.length;t+=1)r.meta[t].lazyArray=new c({...r.meta[t].arrayParams,readFile:this.readFile},e);s._histograms=r}return s._histograms&&Object.keys(s._histograms).forEach(t=>{s._histograms[t].forEach(t=>{Object.keys(t).forEach(e=>{"string"==typeof t[e]&&String(Number(t[e]))===t[e]&&(t[e]=Number(t[e]))})})}),s}async getRegionStats(t){return(await this.getDataRoot(t.ref)).stats}async getRegionFeatureDensities({refName:t,start:e,end:s,numBins:r,basesPerBin:a}){let i=await this.getDataRoot(t);if(r)a=(s-e)/r;else if(a)r=Math.ceil((s-e)/a);else throw TypeError("numBins or basesPerBin arg required for getRegionFeatureDensities");let n=(i._histograms.stats||[]).find(t=>t.basesPerBin>=a),o=i._histograms.meta[0];for(let t=0;t<i._histograms.meta.length;t+=1)a>=i._histograms.meta[t].basesPerBin&&(o=i._histograms.meta[t]);let h=a/o.basesPerBin;if(h>.9&&1e-4>Math.abs(h-Math.round(h))){let t=Math.floor(e/o.basesPerBin);h=Math.round(h);let s=[];for(let t=0;t<r;t+=1)s[t]=0;for await(let[e,a]of o.lazyArray.range(t,t+h*r-1))s[Math.floor((e-t)/h)]+=a;return{bins:s,stats:n}}return{bins:await i.nclist.histogram(e,s,r),stats:n}}async *getFeatures({refName:t,start:e,end:s}){let r=await this.getDataRoot(t),a=r.attrs?.accessors();for await(let[i,n]of r.nclist.iterate(e,s)){if(!i.decorated){let e=n.join(",");this.decorateFeature(a,i,`${t},${e}`)}yield i}}decorateFeature(t,e,s,r){e.get=t.get,e.tags=t.tags,e._uniqueID=s,e.id=u,e._parent=r,e.parent=f,e.children=d,(e.get("subfeatures")||[]).forEach((r,a)=>{this.decorateFeature(t,r,`${s}-${a}`,e)}),e.decorated=!0}}var b=s(77207),m=s(52427),p=s(47368),w=s(9762);let y={refName:"seq_id"},k={seq_id:"refName"};class C{constructor(t,e,s){this.ncFeature=t,this.uniqueId=s||t.id(),this.parentHandle=e}set(){throw Error("not implemented")}jb2TagToJb1Tag(t){return(y[t]||t).toLowerCase()}jb1TagToJb2Tag(t){let e=t.toLowerCase();return k[e]||e}get(t){let e=this.ncFeature.get(this.jb2TagToJb1Tag(t));return e&&"subfeatures"===t?e.map(t=>new C(t,this)):e}tags(){return this.ncFeature.tags().map(t=>this.jb1TagToJb2Tag(t))}id(){return this.uniqueId}parent(){return this.parentHandle}children(){return this.get("subfeatures")}toJSON(){let t={uniqueId:this.id()};for(let e of this.ncFeature.tags()){let s=this.jb1TagToJb2Tag(e),r=this.ncFeature.get(e);"subfeatures"===s?t.subfeatures=(r||[]).map(t=>new C(t,this).toJSON()):t[s]=r}return t}}class E extends b.BaseFeatureDataAdapter{constructor(t,e,s){super(t,e,s);let r=this.getConf("refNames"),a=this.getConf("rootUrlTemplate");this.configRefNames=r,this.nclist=new g({baseUrl:"",urlTemplate:a.uri,readFile:t=>new w.Z(String(a.baseUri?new URL(t,a.baseUri).toString():t)).readFile()})}getFeatures(t,e={}){return(0,m.ObservableCreate)(async s=>{let{stopToken:r}=e;for await(let a of this.nclist.getFeatures(t,e))(0,p.checkStopToken)(r),s.next(this.wrapFeature(a));s.complete()})}wrapFeature(t){return new C(t,void 0,`${this.id}-${t.id()}`)}async hasDataForRefName(t){var e;let s=await this.nclist.getDataRoot(t);return!!(null===(e=null==s?void 0:s.stats)||void 0===e?void 0:e.featureCount)}async getRefNames(){return this.configRefNames||[]}}},93458:function(t){var e;e=function(){"use strict";let t=/^[\w+.-]+:\/\//,e=/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,s=/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;function r(t){return t.startsWith("/")}function a(t){return/^[.?#]/.test(t)}function i(t){let s=e.exec(t);return n(s[1],s[2]||"",s[3],s[4]||"",s[5]||"/",s[6]||"",s[7]||"")}function n(t,e,s,r,a,i,n){return{scheme:t,user:e,host:s,port:r,path:a,query:i,hash:n,type:7}}function o(e){if(e.startsWith("//")){let t=i("http:"+e);return t.scheme="",t.type=6,t}if(r(e)){let t=i("http://foo.com"+e);return t.scheme="",t.host="",t.type=5,t}if(e.startsWith("file:"))return function(t){let e=s.exec(t),a=e[2];return n("file:","",e[1]||"","",r(a)?a:"/"+a,e[3]||"",e[4]||"")}(e);if(t.test(e))return i(e);let a=i("http://foo.com/"+e);return a.scheme="",a.host="",a.type=e?e.startsWith("?")?3:e.startsWith("#")?2:4:1,a}function h(t,e){let s=e<=4,r=t.path.split("/"),a=1,i=0,n=!1;for(let t=1;t<r.length;t++){let e=r[t];if(!e){n=!0;continue}if(n=!1,"."!==e){if(".."===e){i?(n=!0,i--,a--):s&&(r[a++]=e);continue}r[a++]=e,i++}}let o="";for(let t=1;t<a;t++)o+="/"+r[t];o&&(!n||o.endsWith("/.."))||(o+="/"),t.path=o}return function(t,e){if(!t&&!e)return"";let s=o(t),r=s.type;if(e&&7!==r){let t=o(e),a=t.type;switch(r){case 1:s.hash=t.hash;case 2:s.query=t.query;case 3:case 4:h(t,t.type),"/"===s.path?s.path=t.path:s.path=function(t){if(t.endsWith("/.."))return t;let e=t.lastIndexOf("/");return t.slice(0,e+1)}(t.path)+s.path;case 5:s.user=t.user,s.host=t.host,s.port=t.port;case 6:s.scheme=t.scheme}a>r&&(r=a)}h(s,r);let i=s.query+s.hash;switch(r){case 2:case 3:return i;case 4:{let r=s.path.slice(1);if(!r)return i||".";if(a(e||t)&&!a(r))return"./"+r+i;return r+i}case 5:return s.path+i;default:return s.scheme+"//"+s.user+s.host+s.port+s.path+i}}},t.exports=e()},93900:function(t,e,s){"use strict";s.d(e,{Z:function(){return n}});class r{}class a{constructor(){this.signals=new Set,this.abortController=new AbortController}addSignal(t=new r){if(this.signal.aborted)throw Error("cannot add a signal, already aborted!");this.signals.add(t),t.aborted?this.handleAborted(t):"function"==typeof t.addEventListener&&t.addEventListener("abort",()=>{this.handleAborted(t)})}handleAborted(t){this.signals.delete(t),0===this.signals.size&&this.abortController.abort()}get signal(){return this.abortController.signal}abort(){this.abortController.abort()}}class i{constructor(){this.callbacks=new Set}addCallback(t=()=>{}){this.callbacks.add(t),this.currentMessage&&t(this.currentMessage)}callback(t){for(let e of(this.currentMessage=t,this.callbacks))e(t)}}class n{constructor({fill:t,cache:e}){if("function"!=typeof t)throw TypeError("must pass a fill function");if("object"!=typeof e)throw TypeError("must pass a cache object");if("function"!=typeof e.get||"function"!=typeof e.set||"function"!=typeof e.delete)throw TypeError("cache must implement get(key), set(key, val), and and delete(key)");this.cache=e,this.fillCallback=t}static isAbortException(t){return"AbortError"===t.name||"ERR_ABORTED"===t.code||"AbortError: aborted"===t.message||"Error: aborted"===t.message}evict(t,e){this.cache.get(t)===e&&this.cache.delete(t)}fill(t,e,s,r){let n=new a,o=new i;o.addCallback(r);let h={aborter:n,promise:this.fillCallback(e,n.signal,t=>{o.callback(t)}),settled:!1,statusReporter:o,get aborted(){return this.aborter.signal.aborted}};h.aborter.addSignal(s),h.aborter.signal.addEventListener("abort",()=>{h.settled||this.evict(t,h)}),h.promise.then(()=>{h.settled=!0},()=>{h.settled=!0,this.evict(t,h)}).catch(t=>{throw console.error(t),t}),this.cache.set(t,h)}static checkSinglePromise(t,e){function s(){if(e?.aborted)throw Object.assign(Error("aborted"),{code:"ERR_ABORTED"})}return t.then(t=>(s(),t),t=>{throw s(),t})}has(t){return this.cache.has(t)}get(t,e,s,r){if(!s&&e instanceof AbortSignal)throw TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");let a=this.cache.get(t);return a?a.aborted&&!a.settled?(this.evict(t,a),this.get(t,e,s,r)):a.settled?a.promise:(a.aborter.addSignal(s),a.statusReporter.addCallback(r),n.checkSinglePromise(a.promise,s)):(this.fill(t,e,s,r),n.checkSinglePromise(this.cache.get(t).promise,s))}delete(t){let e=this.cache.get(t);e&&(e.settled||e.aborter.abort(),this.cache.delete(t))}clear(){let t=this.cache.keys(),e=0;for(let s=t.next();!s.done;s=t.next())this.delete(s.value),e+=1;return e}}},9762:function(t,e,s){"use strict";function r(t){return("object"==typeof t&&null!==t&&"message"in t?t.message:`${t}`).replace(/\.$/,"")}s.d(e,{Z:function(){return a}});class a{constructor(t,e={}){this.baseOverrides={},this.url=t;let s=e.fetch||globalThis.fetch.bind(globalThis);e.overrides&&(this.baseOverrides=e.overrides),this.fetchImplementation=s}async fetch(t,e){let s;try{s=await this.fetchImplementation(t,e)}catch(a){if(`${a}`.includes("Failed to fetch")){console.warn(`generic-filehandle: refetching ${t} to attempt to work around chrome CORS header caching bug`);try{s=await this.fetchImplementation(t,{...e,cache:"reload"})}catch(e){throw Error(`${r(e)} fetching ${t}`,{cause:e})}}else throw Error(`${r(a)} fetching ${t}`,{cause:a})}return s}async read(t,e,s={}){let{headers:r={},signal:a,overrides:i={}}=s;t<1/0?r.range=`bytes=${e}-${e+t}`:t===1/0&&0!==e&&(r.range=`bytes=${e}-`);let n=await this.fetch(this.url,{...this.baseOverrides,...i,headers:{...r,...i.headers,...this.baseOverrides.headers},method:"GET",redirect:"follow",mode:"cors",signal:a});if(!n.ok)throw Error(`HTTP ${n.status} fetching ${this.url}`);if(200===n.status&&0===e||206===n.status){let e=await n.arrayBuffer(),s=n.headers.get("content-range"),r=/\/(\d+)$/.exec(s||"");return r?.[1]&&(this._stat={size:parseInt(r[1],10)}),new Uint8Array(e.slice(0,t))}if(200===n.status)throw Error(`${this.url} fetch returned status 200, expected 206`);throw Error(`HTTP ${n.status} fetching ${this.url}`)}async readFile(t={}){let e,s;"string"==typeof t?(e=t,s={}):(e=t.encoding,s=t,delete s.encoding);let{headers:r={},signal:a,overrides:i={}}=s,n=await this.fetch(this.url,{headers:r,method:"GET",redirect:"follow",mode:"cors",signal:a,...this.baseOverrides,...i});if(200!==n.status)throw Error(`HTTP ${n.status} fetching ${this.url}`);if("utf8"===e)return n.text();if(!e)return new Uint8Array(await n.arrayBuffer());throw Error(`unsupported encoding: ${e}`)}async stat(){if(!this._stat&&(await this.read(10,0),!this._stat))throw Error(`unable to determine size of file at ${this.url}`);return this._stat}async close(){}}}}]);